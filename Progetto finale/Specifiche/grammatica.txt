//GRAMMATICA LABORATORI 10/11

Prog ::= StmtSeq 'EOF'
StmtSeq ::= Stmt | Stmt ';' StmtSeq
Stmt ::= 'var' ID '=' Exp | ID '=' Exp | 'print' Exp |  'for' ID ':' Exp '{' StmtSeq '}'
ExpSeq ::= Exp | Exp ',' ExpSeq
Exp ::= Exp BinOp Exp | '-' Exp| '[' ExpSeq ']' | NUM | ID | '(' Exp ')'
BinOp ::= '::' | '+' | '*'

Grammatica non ambigua

Prog ::= StmtSeq 'EOF'
StmtSeq ::= Stmt (';' StmtSeq)?
Stmt ::= 'var'? ID '=' Exp | 'print' Exp |  'for' ID ':' Exp '{' StmtSeq '}'
ExpSeq ::= Exp (',' ExpSeq)?
Exp ::= Add ('::' Exp)?
Add ::= Mul ('+' Mul)*
Mul::= Atom ('*' Atom)*
Atom ::= '-' Atom | '[' ExpSeq ']' | NUM | ID | '(' Exp ')'



GRAMMATICA PROGETTO FINALE

da aggiungere:
CATEGORIE LESSICALI
   -literal di tipo boolean rappresentati dalle due keywordfalseetrue
   -literal interi di tipo binario: iniziano con la cifra0, seguita dalla letteraboBe terminano con una sequenzanonvuotadi cifre binarie. L’interpretazione`e quella convenzionale: per esempio, il literal0b0111denota il numero 7.

SINTASSI DELLE ESPRESSIONI
   -operatori binari: {&&, ==}; Associano entrambi a sinistra
   -operatori unari: {!, opt, empty, def, get}; Hanno la precedenza sugli operatoribinari infissi
   -Exp ::= (quello che c'era per il lab 10) | Exp && Exp | Exp == Exp | !Exp | opt Exp  |empty Exp | def Exp | get Exp
   -opt,empty,defegetsono nuove keyword
   -Per trattare correttamente il riconoscimento dei lessemi = e == tramite un’espressione regolare, elencare prima ==; quindi l’espressione regolare di forma == | = `e quella corretta
   Precedenza operatori binari:
      1) &&    precedenza più bassa
      2) ==
      3) ::
      4) +
      5) *     precedenza più alta

SINTASSI DEGLI STATEMENT
   -Stmt ::= (quello che c'era per il lab 10) | if (Exp) {StmtSeq} (else {StmtSeq})? | do {StmtSeq} while (Exp)
   -if, else, do e while sono nuove keyword.
   -la parte introdotta dalla keywordelse`e opzionale
   

DA COMPLETARE E DISAMBIGUARE
Prog ::= StmtSeq 'EOF'
StmtSeq ::= Stmt | Stmt ';' StmtSeq
Stmt ::= 'var' ID '=' Exp | ID '=' Exp | 'print' Exp |  'for' ID ':' Exp '{' StmtSeq '}'
ExpSeq ::= Exp | Exp ',' ExpSeq
Exp ::= Exp BinOp Exp | '-' Exp| '[' ExpSeq ']' | NUM | ID | '(' Exp ')'
BinOp ::= '::' | '+' | '*'
